(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{508:function(t,a,s){"use strict";s.r(a);var e=s(35),i=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"http缓存控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http缓存控制"}},[t._v("#")]),t._v(" http缓存控制")]),t._v(" "),s("h2",{attrs:{id:"题意分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#题意分析"}},[t._v("#")]),t._v(" 题意分析")]),t._v(" "),s("ul",[s("li",[t._v("Web缓存大致可以分为:数据库缓存、服务器端缓存(代理服务器缓存、CDN缓存)、浏览器缓存。")]),t._v(" "),s("li",[t._v("浏览器缓存也包含很多内容: HTTP缓存、indexDB、 cookie, localstorage等等。这里我们只讨论HTTP缓存相关内容。")]),t._v(" "),s("li",[t._v("在具体了解HTTP缓存之前先来明确几个术语:\n"),s("ul",[s("li",[t._v("缓存命中率:从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。")]),t._v(" "),s("li",[t._v("过期内容:超过设置的有效时间,被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求,必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。")]),t._v(" "),s("li",[t._v("验证:验证缓存中的过期内容是否仍然有效,验证通过的话刷新过期时间。")]),t._v(" "),s("li",[t._v("失效:失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。")])])]),t._v(" "),s("li",[t._v("浏览器缓存主要是HTTP 协议定义的缓存机制。HTML meta标签,例如")])]),t._v(" "),s("div",{staticClass:"language-html line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("meta")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("http-equiv")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("Pragma"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("content")]),s("span",{pre:!0,attrs:{class:"token attr-value"}},[s("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("no-store"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[t._v("含义是让浏览器不缓存当前页面。但是代理服务器不解析HTML内容,一般应用广泛的是用HTTP头信息控制缓存。")])]),t._v(" "),s("p",[t._v("浏览器缓存分类：")]),t._v(" "),s("ul",[s("li",[t._v("浏览器缓存分为强缓存和协商缓存,浏览器加载一个页面的简单流程如下:\n"),s("ul",[s("li",[t._v("浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源,并不会将请求发送到服务器。（强缓存）")]),t._v(" "),s("li",[t._v("如果未命中强缓存,则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用,则服务器并不会返回资源信息,浏览器继续从缓存加载资源（协商缓存）")]),t._v(" "),s("li",[t._v("如果未命中协商缓存,则服务器会将完整的资源返回给浏览器,浏览器加载新资源,并更新缓存。（新的请求）")])])])]),t._v(" "),s("p",[t._v("强缓存:\n命中强缓存时,浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200,但是在Size列会显示为(from cache)。\n"),s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306145935.png",alt:"cache"}})]),t._v(" "),s("ul",[s("li",[t._v("强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的,用来表示资源的缓存时间。")])]),t._v(" "),s("p",[t._v("Expires:")]),t._v(" "),s("ul",[s("li",[t._v("缓存过期时间,用来指定资源到期的时间,是服务器端的具体的时间点。也就是说,Expires=max-age + 请求时间,需要和Last-modified结合使用。但在上面我们提到过,cache-control的优先级更高。Expires是Web服务器响应消息头字段,在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据,而无需再次请求。\n"),s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306150107.png",alt:"expires"}})]),t._v(" "),s("li",[t._v("该字段会返回一个时间,比如Expires:Thu,31 Dec 2037 23:59:59 GMT。这个时间代表着这个资源的失效时间,也就是说在2037年12月31日23点59分59秒之前都是有效的,即命中缓存。这种方式有一个明显的缺点,曲于失效时间是一个绝对时间,所以当客户端本地时间被修改以后,服务器与客户端时间偏差变大以后,就会导致缓存混乱。于是发展出了\nCache-Control。")])]),t._v(" "),s("p",[t._v("Cache-Control:")]),t._v(" "),s("ul",[s("li",[t._v("Cache-Control是一个相对时间,例如Cache-Control:3600,代表着资源的有效期是3600秒。由于是相对时间,并且都是与客户端时间比较,所以服务器与客户端时间偏差也不会导致问题。")]),t._v(" "),s("li",[t._v("Cache-Control与Expires可以在服务端配置同时启用或者启用任意一个,同时启用的时候Cache-Control优先级高。")]),t._v(" "),s("li",[t._v("Cache-Control可以由多个字段组合而成,主要有以下几个取值:\n"),s("ul",[s("li",[t._v("max-age指定一个时间长度,在这个时间段内缓存是有效的,单位是s。例如设置Cache-Control:max-age=31536000,也就是说缓存有效期为(31536000/ 24/ 60 *60)天,第一次访问这个资源的时候,服务器端也返回了Expires字段,并且过期时间是一年后。")]),t._v(" "),s("li",[s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306150339.png",alt:"cache-control"}})]),t._v(" "),s("li",[t._v("在没有禁用缓存并且没有超过有效时间的情况下,再次访问这个资源就命中了缓存,不会向服务器请求资源而是直接从浏览器缓存中取。\n"),s("ul",[s("li",[t._v("s-maxage 同max-age,覆盖 max-age、Expires,但仅适用于共享缓存,在私有缓存中被忽略。")]),t._v(" "),s("li",[t._v("public 表明响应可以被任何对象(发送请求的客户端、代理服务器等缓存")]),t._v(" "),s("li",[t._v("private 表明响应只能被单个用户(可能是操作系统用户、浏览器用户)缓存,是非共享的,不能被代理服务器缓存。")]),t._v(" "),s("li",[t._v("no-cache强制所有缓存了该响应的用户,在使用已缓存的数据前,发送带验证器的请求到服务器。不是字面意思上的不缓存。")]),t._v(" "),s("li",[t._v("no-store 禁止缓存,每次请求都要向服务器重新获取数据。")]),t._v(" "),s("li",[t._v("must-revalidate指定如果页面是过期的,则去服务器进行获取。这个指令并不常用,就不做过多的讨论了。")])])])])])]),t._v(" "),s("p",[t._v("协商缓存：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("若未命中强缓存,则浏览器会将请求发送至服务器。服务器根据http头信息中的LastModify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中,则http返回码为304,浏览器从缓存中加载资源。")])]),t._v(" "),s("li",[s("p",[t._v("Last-Modify/If-Modify-Since")]),t._v(" "),s("ul",[s("li",[t._v("浏览器第一次请求一个资源的时候,服务器返回的header中会加上Last-Modify, Lastmodify是一个时间标识该资源的最后修改时间,例如Last-Modify: Thu, 31 Dec 2037\n23:59:59 GMT。")]),t._v(" "),s("li",[s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306150839.png",alt:"上次修改时间"}})]),t._v(" "),s("li",[t._v("当浏览器再次请求该资源时,发送的请求头中会包含If-Modify-Since,该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后,根据资源的最后修改时间判断是否命中缓存")]),t._v(" "),s("li",[s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306150942.png",alt:"ifmodify"}})]),t._v(" "),s("li",[t._v("如果命中缓存,则返回http304,并且不会返回资源内容,并且不会返回Last-Modify。由于对比的服务端时间,所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确(资源变化了最后修改时间也可以一致)。于是出现了ETag/If-None-Match.")])])]),t._v(" "),s("li",[s("p",[t._v("ETag/If-None-Match")]),t._v(" "),s("ul",[s("li",[t._v("与Last-Modify/If-Modify-Since不同的是, Etag/If-None-Match返回的是一个校验码(ETag: entity tag).ETag可以保证每一个资源是唯一的,资源变化都会导致ETag变化, ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。")]),t._v(" "),s("li",[s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306151214.png",alt:""}})])])])]),t._v(" "),s("p",[t._v("ETag扩展说明:")]),t._v(" "),s("ul",[s("li",[t._v("我们对ETag寄予厚望,希望它对于每一个url生成唯一的值,资源变化时ETag也发生变化。\n神秘的Etag是如何生成的呢?以Apache为例,ETag生成靠以下几种因子\n"),s("ul",[s("li",[s("ol",[s("li",[t._v("文件的i-node编号,此i-node非彼iNode。是Linux/Unix用来识别文件的编号。是的,识别文件用的不是文件名。使用命令ls-l'可以看到。")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("文件最后修改时间")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"3"}},[s("li",[t._v("文件大小, 生成Etag的时候,可以使用其中一种或几种因子,使用抗碰撞散列函数来生成。所以,理论上ETag也是会重复的,只是概率小到可以忽略。")])])])])])]),t._v(" "),s("p",[t._v("既生Last-Modified何生Etag?")]),t._v(" "),s("ul",[s("li",[t._v("你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新,为什么还需要Etag(实体标识)呢? HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题:\n"),s("ul",[s("li",[s("ol",[s("li",[t._v("Last-Modified标注的最后修改只能精确到秒级,如果某些文件在1秒钟以内,被修改多次的话,它将不能准确标注文件的修改时间")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v("如果某些文件会被定期生成,当有时内容并没有任何变化,但Last-Modified却改变了,导致文件没法使用缓存")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"3"}},[s("li",[t._v("有可能存在服务器没有准确获取文件修改时间,或者与代理服务器时间不一致等情形")])])])])]),t._v(" "),s("li",[t._v("Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符,能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的,服务器会优先验证ETag,一致的情况下,才会继续比对Last-Modified,最后才决定是否返回304。")])]),t._v(" "),s("p",[t._v("浏览器的第一次请求:\n"),s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306151608.png",alt:"first-req"}})]),t._v(" "),s("p",[t._v("浏览器第二次请求：\n"),s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306151806.png",alt:"second-req"}})]),t._v(" "),s("h2",{attrs:{id:"明确考察点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#明确考察点"}},[t._v("#")]),t._v(" 明确考察点")]),t._v(" "),s("ol",[s("li",[t._v("http缓存作用范围")]),t._v(" "),s("li",[t._v("http缓存分类")]),t._v(" "),s("li",[t._v("http缓存实现技术")])]),t._v(" "),s("h2",{attrs:{id:"回答思路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回答思路"}},[t._v("#")]),t._v(" 回答思路")]),t._v(" "),s("ul",[s("li",[t._v("首先回答http缓存的作用范围,然后点出http缓存主要分为强缓存和协商缓存。最后重点闻述强缓存和协商缓存的配置实现和相关http响应头字段的用法。")])]),t._v(" "),s("h2",{attrs:{id:"相关扩展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#相关扩展"}},[t._v("#")]),t._v(" 相关扩展")]),t._v(" "),s("p",[t._v("1.用户行为与缓存浏览器缓存行为还有用户的行为有关!!.")]),t._v(" "),s("h2",{attrs:{id:"强缓存nginx配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强缓存nginx配置"}},[t._v("#")]),t._v(" 强缓存nginx配置")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("修改nginx.conf")])]),t._v(" "),s("li",[s("p",[t._v("index.html 两个p文字 一个img图片（2.jpg考察是否强缓存）")])]),t._v(" "),s("li",[s("p",[t._v("一开始打开浏览器localhost 未命中强缓存")])]),t._v(" "),s("li",[s("p",[t._v("刷新一遍看强缓存 未命中强缓存 304 not modified(这个是协商缓存)")])]),t._v(" "),s("li",[s("p",[t._v("原始配置\n"),s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306154254.png",alt:"原封不动-强缓存"}})])]),t._v(" "),s("li",[s("p",[t._v("开启强缓存配置 修改为60s更好测试\n"),s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306154355.png",alt:"开启强缓存"}})])]),t._v(" "),s("li",[s("p",[t._v("重启nginx")])]),t._v(" "),s("li",[s("p",[t._v("ctrl + f5 强刷新")])]),t._v(" "),s("li",[s("p",[t._v("第一次请求："),s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306154522.png",alt:"强缓存"}})])]),t._v(" "),s("li",[s("p",[t._v("第二次请求，命中强缓存啦,从缓存中取用静态资源："),s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306154636.png",alt:"强缓存"}})])])]),t._v(" "),s("h2",{attrs:{id:"协商缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306155442.png",alt:"协商缓存"}})]),t._v(" "),s("h2",{attrs:{id:"nginx使用etag"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nginx使用etag"}},[t._v("#")]),t._v(" nginx使用etag")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("走协商缓存自动就会用etag\n"),s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306160418.png",alt:"etag"}})])]),t._v(" "),s("li",[s("p",[t._v("重启nginx")])]),t._v(" "),s("li",[s("p",[t._v("强刷新一下 200,")])]),t._v(" "),s("li",[s("p",[t._v("headers里有etag")])]),t._v(" "),s("li",[s("p",[t._v("三次刷新比对\n"),s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306160712.png",alt:"协商"}})])]),t._v(" "),s("li",[s("p",[t._v("文件变化就是etag变化，手动修改index.html")])]),t._v(" "),s("li",[s("p",[t._v("再次强刷新")])]),t._v(" "),s("li",[s("p",[t._v("比对图\n"),s("img",{attrs:{src:"https://gitee.com/toprhythm/pic-bed/raw/master/01-javase-pics/20220306160813.png",alt:"etag"}})])])]),t._v(" "),s("h2",{attrs:{id:"缓存总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存总结"}},[t._v("#")]),t._v(" 缓存总结")]),t._v(" "),s("ul",[s("li",[t._v("http缓存能够帮助服务器提高并发性能,很多资源不需要重复请求直接从浏览器中拿缓存")]),t._v(" "),s("li",[t._v("http缓存分类:强缓存协商缓存")]),t._v(" "),s("li",[t._v("强缓存通过\nexpires cache-control 协商 通 last-Modify\n和E-tag控制")])]),t._v(" "),s("p",[t._v("补充：")]),t._v(" "),s("ol",[s("li",[t._v("为什么有expires又需要cache-control?")])]),t._v(" "),s("ul",[s("li",[t._v("因为expires有个服务器和浏览器时间不同步的问题")]),t._v(" "),s("li",[t._v("expires是绝对事件\ncache-control是相对时间")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("last-modify和Etag")])]),t._v(" "),s("ul",[s("li",[t._v("last-modify它是有个精度问题 到秒")]),t._v(" "),s("li",[t._v("e-tag没有精度问题 只要文件改变 e-tag值就改变")])])])}),[],!1,null,null,null);a.default=i.exports}}]);